
scalar JSON
scalar Date

type Site {
  title: String
  url: String
  logoUrl: String
  sourceVersion: String
}
type IntlValue {
  locale: String
  value: String
}
input IntlValueInput{
  locale: String
  value: String
}
directive @intl on FIELD_DEFINITION

# A user object
type User {
  _id: String
  username: String
  emails: [JSON]
  createdAt: Date
  isAdmin: Boolean
  locale: String
  profile: JSON
  services: JSON
  displayName: String
  email: String
  emailHash: String
  avatarUrl: String
  slug: String
  twitterUsername: String
  groups: [String]
  pageUrl: String
  pagePath: String
  editUrl: String
  commentCount: Float
  bio: String
  htmlBio: String
  website: String
  updatedAt: Date
}


input DeleteUserInput{
  selector: UserSelectorUniqueInput!
}

input SingleUserInput {
  selector: UserSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiUserInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: UserSelectorInput
  orderBy: UserOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleUserOutput{
  result: User
}

type MultiUserOutput{
  results: [User]
  totalCount: Int
}

type UserOutput{
  data: User
}

input CreateUserInput{
  data: CreateUserDataInput!
}

input CreateUserDataInput {
  username: String
  isAdmin: Boolean
  locale: String
  profile: JSON
  displayName: String
  email: String
  twitterUsername: String
  groups: [String]
  bio: String
  website: String
  updatedAt: Date
}

input UpdateUserInput{
  selector: UserSelectorUniqueInput!
  data: UpdateUserDataInput!
}

input UpsertUserInput{
  selector: UserSelectorUniqueInput!
  data: UpdateUserDataInput!
}

input UpdateUserDataInput {
  username: String
  isAdmin: Boolean
  locale: String
  displayName: String
  email: String
  twitterUsername: String
  groups: [String]
  bio: String
  website: String
  updatedAt: Date
}

input UserSelectorInput {
  AND: [UserSelectorInput]
  OR: [UserSelectorInput]

}

input UserSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum UserOrderByInput {
  foobar

}


# Type for Settings
type Setting {
  name: String
  value: JSON
  defaultValue: JSON
  isPublic: Boolean
  description: String
}


input DeleteSettingInput{
  selector: SettingSelectorUniqueInput!
}

input SingleSettingInput {
  selector: SettingSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiSettingInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: SettingSelectorInput
  orderBy: SettingOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleSettingOutput{
  result: Setting
}

type MultiSettingOutput{
  results: [Setting]
  totalCount: Int
}

type SettingOutput{
  data: Setting
}

input SettingSelectorInput {
  AND: [SettingSelectorInput]
  OR: [SettingSelectorInput]

}

input SettingSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum SettingOrderByInput {
  foobar

}


# Type for Callbacks
type Callback {
  name: String
  iterator: JSON
  properties: [JSON]
  runs: String
  newSyntax: Boolean
  returns: String
  description: String
  hooks: [String]
}


input DeleteCallbackInput{
  selector: CallbackSelectorUniqueInput!
}

input SingleCallbackInput {
  selector: CallbackSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCallbackInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: CallbackSelectorInput
  orderBy: CallbackOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCallbackOutput{
  result: Callback
}

type MultiCallbackOutput{
  results: [Callback]
  totalCount: Int
}

type CallbackOutput{
  data: Callback
}

input CallbackSelectorInput {
  AND: [CallbackSelectorInput]
  OR: [CallbackSelectorInput]

}

input CallbackSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CallbackOrderByInput {
  foobar

}


# Type for Projects
type Project {
  _id: String
  createdAt: Date
  userId: String
  updatedAt: Date
  projectTitle: String
  sortTitle: String
  projectType: String
  platformType: String
  union: String
  network: String
  status: String
  renewed: Boolean
  summary: String
  htmlSummary: String
  website: String
  notes: String
  htmlNotes: String
  season: String
  order: String
  casting: String
  castingCompany: String
  castingOffice: Office
  castingOfficeId: String
  slug: String
  links: [JSON]
  contacts: [JSON]
  allContactNames: String
  addresses: [JSON]
  allAddresses: String
}


input DeleteProjectInput{
  selector: ProjectSelectorUniqueInput!
}

input SingleProjectInput {
  selector: ProjectSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiProjectInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: ProjectSelectorInput
  orderBy: ProjectOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleProjectOutput{
  result: Project
}

type MultiProjectOutput{
  results: [Project]
  totalCount: Int
}

type ProjectOutput{
  data: Project
}

input CreateProjectInput{
  data: CreateProjectDataInput!
}

input CreateProjectDataInput {
  projectTitle: String
  sortTitle: String
  projectType: String
  union: String
  network: String
  status: String
  renewed: Boolean
  summary: String
  htmlSummary: String
  website: String
  notes: String
  htmlNotes: String
  season: String
  order: String
  castingCompany: String
  castingOfficeId: String
  slug: String
  links: [JSON]
  contacts: [JSON]
  addresses: [JSON]
}

input UpdateProjectInput{
  selector: ProjectSelectorUniqueInput!
  data: UpdateProjectDataInput!
}

input UpsertProjectInput{
  selector: ProjectSelectorUniqueInput!
  data: UpdateProjectDataInput!
}

input UpdateProjectDataInput {
  projectTitle: String
  sortTitle: String
  projectType: String
  union: String
  network: String
  status: String
  renewed: Boolean
  summary: String
  htmlSummary: String
  website: String
  notes: String
  htmlNotes: String
  season: String
  order: String
  castingCompany: String
  castingOfficeId: String
  slug: String
  links: [JSON]
  contacts: [JSON]
  addresses: [JSON]
}

input ProjectSelectorInput {
  AND: [ProjectSelectorInput]
  OR: [ProjectSelectorInput]

}

input ProjectSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ProjectOrderByInput {
  foobar

}


# Type for PastProjects
type PastProject {
  _id: String
  createdAt: Date
  userId: String
  updatedAt: Date
  projectTitle: String
  projectType: String
  platformType: String
  union: String
  network: String
  status: String
  renewed: Boolean
  summary: String
  htmlSummary: String
  website: String
  notes: String
  htmlNotes: String
  season: String
  order: String
  casting: String
  castingCompany: String
  castingOffice: Office
  castingOfficeId: String
  slug: String
  links: [JSON]
  contacts: [JSON]
  allContactNames: String
  addresses: [JSON]
  allAddresses: String
}


input DeletePastProjectInput{
  selector: PastProjectSelectorUniqueInput!
}

input SinglePastProjectInput {
  selector: PastProjectSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiPastProjectInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: PastProjectSelectorInput
  orderBy: PastProjectOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SinglePastProjectOutput{
  result: PastProject
}

type MultiPastProjectOutput{
  results: [PastProject]
  totalCount: Int
}

type PastProjectOutput{
  data: PastProject
}

input CreatePastProjectInput{
  data: CreatePastProjectDataInput!
}

input CreatePastProjectDataInput {
  projectTitle: String
  projectType: String
  union: String
  network: String
  status: String
  renewed: Boolean
  summary: String
  htmlSummary: String
  website: String
  notes: String
  htmlNotes: String
  season: String
  order: String
  castingCompany: String
  castingOfficeId: String
  slug: String
  links: [JSON]
  contacts: [JSON]
  addresses: [JSON]
}

input UpdatePastProjectInput{
  selector: PastProjectSelectorUniqueInput!
  data: UpdatePastProjectDataInput!
}

input UpsertPastProjectInput{
  selector: PastProjectSelectorUniqueInput!
  data: UpdatePastProjectDataInput!
}

input UpdatePastProjectDataInput {
  projectTitle: String
  projectType: String
  union: String
  network: String
  status: String
  renewed: Boolean
  summary: String
  htmlSummary: String
  website: String
  notes: String
  htmlNotes: String
  season: String
  order: String
  castingCompany: String
  castingOfficeId: String
  slug: String
  links: [JSON]
  contacts: [JSON]
  addresses: [JSON]
}

input PastProjectSelectorInput {
  AND: [PastProjectSelectorInput]
  OR: [PastProjectSelectorInput]

}

input PastProjectSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum PastProjectOrderByInput {
  foobar

}


# Type for Offices
type Office {
  _id: String
  createdAt: Date
  userId: String
  displayName: String
  body: String
  htmlBody: String
  links: [JSON]
  addresses: [JSON]
  allAddresses: String
  slug: String
  updatedAt: Date
  theProjects: [Project]
  projects: [JSON]
  pastProjects: [JSON]
  theContacts: [Contact]
  contacts: [JSON]
  allContactNames: String
  fullAddress: String
  street: String
  location: String
  theStreet: String
  theStreet1: String
  theStreet2: String
  theCity: String
  theState: String
  theLocation: String
  theZip: String
}


input DeleteOfficeInput{
  selector: OfficeSelectorUniqueInput!
}

input SingleOfficeInput {
  selector: OfficeSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiOfficeInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: OfficeSelectorInput
  orderBy: OfficeOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleOfficeOutput{
  result: Office
}

type MultiOfficeOutput{
  results: [Office]
  totalCount: Int
}

type OfficeOutput{
  data: Office
}

input CreateOfficeInput{
  data: CreateOfficeDataInput!
}

input CreateOfficeDataInput {
  displayName: String
  body: String
  htmlBody: String
  links: [JSON]
  addresses: [JSON]
  projects: [JSON]
  pastProjects: [JSON]
  contacts: [JSON]
}

input UpdateOfficeInput{
  selector: OfficeSelectorUniqueInput!
  data: UpdateOfficeDataInput!
}

input UpsertOfficeInput{
  selector: OfficeSelectorUniqueInput!
  data: UpdateOfficeDataInput!
}

input UpdateOfficeDataInput {
  displayName: String
  body: String
  htmlBody: String
  links: [JSON]
  addresses: [JSON]
  projects: [JSON]
  pastProjects: [JSON]
  contacts: [JSON]
}

input OfficeSelectorInput {
  AND: [OfficeSelectorInput]
  OR: [OfficeSelectorInput]

}

input OfficeSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum OfficeOrderByInput {
  foobar

}


# Type for Contacts
type Contact {
  _id: String
  createdAt: Date
  userId: String
  firstName: String
  middleName: String
  lastName: String
  displayName: String
  title: String
  gender: String
  body: String
  htmlBody: String
  links: [JSON]
  allLinks: String
  addresses: [JSON]
  allAddresses: String
  addressString: String
  theAddress: JSON
  slug: String
  updatedAt: Date
  offices: [JSON]
  projects: [JSON]
  pastProjects: [JSON]
  fullName: String
}


input DeleteContactInput{
  selector: ContactSelectorUniqueInput!
}

input SingleContactInput {
  selector: ContactSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiContactInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: ContactSelectorInput
  orderBy: ContactOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleContactOutput{
  result: Contact
}

type MultiContactOutput{
  results: [Contact]
  totalCount: Int
}

type ContactOutput{
  data: Contact
}

input CreateContactInput{
  data: CreateContactDataInput!
}

input CreateContactDataInput {
  firstName: String
  middleName: String
  lastName: String
  displayName: String
  title: String
  gender: String
  body: String
  htmlBody: String
  links: [JSON]
  addresses: [JSON]
  addressString: String
  slug: String
  offices: [JSON]
  projects: [JSON]
  pastProjects: [JSON]
}

input UpdateContactInput{
  selector: ContactSelectorUniqueInput!
  data: UpdateContactDataInput!
}

input UpsertContactInput{
  selector: ContactSelectorUniqueInput!
  data: UpdateContactDataInput!
}

input UpdateContactDataInput {
  firstName: String
  middleName: String
  lastName: String
  displayName: String
  title: String
  gender: String
  body: String
  htmlBody: String
  links: [JSON]
  addresses: [JSON]
  addressString: String
  slug: String
  offices: [JSON]
  projects: [JSON]
  pastProjects: [JSON]
}

input ContactSelectorInput {
  AND: [ContactSelectorInput]
  OR: [ContactSelectorInput]

}

input ContactSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum ContactOrderByInput {
  foobar

}


# Type for Comments
type Comment {
  _id: String
  createdAt: Date
  user: User
  userId: String
  parentComment: Comment
  parentCommentId: String
  topLevelComment: Comment
  topLevelCommentId: String
  postedAt: Date
  body: String
  htmlBody: String
  author: String
  collectionName: String
  objectId: String
  isDeleted: Boolean
}


input DeleteCommentInput{
  selector: CommentSelectorUniqueInput!
}

input SingleCommentInput {
  selector: CommentSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiCommentInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: CommentSelectorInput
  orderBy: CommentOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleCommentOutput{
  result: Comment
}

type MultiCommentOutput{
  results: [Comment]
  totalCount: Int
}

type CommentOutput{
  data: Comment
}

input CreateCommentInput{
  data: CreateCommentDataInput!
}

input CreateCommentDataInput {
  userId: String
  parentCommentId: String
  topLevelCommentId: String
  body: String
  collectionName: String
  objectId: String
}

input UpdateCommentInput{
  selector: CommentSelectorUniqueInput!
  data: UpdateCommentDataInput!
}

input UpsertCommentInput{
  selector: CommentSelectorUniqueInput!
  data: UpdateCommentDataInput!
}

input UpdateCommentDataInput {
  body: String
}

input CommentSelectorInput {
  AND: [CommentSelectorInput]
  OR: [CommentSelectorInput]

}

input CommentSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum CommentOrderByInput {
  foobar

}


# Type for Statistics
type Statistics {
  _id: String
  createdAt: Date
  userId: String
  updatedAt: Date
  episodics: [JSON]
  pilots: [JSON]
  features: [JSON]
  others: [JSON]
}


input DeleteStatisticsInput{
  selector: StatisticsSelectorUniqueInput!
}

input SingleStatisticsInput {
  selector: StatisticsSelectorUniqueInput
  # Whether to enable caching for this query
  enableCache: Boolean
  # Return null instead of throwing MissingDocumentError
  allowNull: Boolean
}

input MultiStatisticsInput {
  # A JSON object that contains the query terms used to fetch data
  terms: JSON,
  # How much to offset the results by
  offset: Int,
  # A limit for the query
  limit: Int,
  # Whether to enable caching for this query
  enableCache: Boolean
  # Whether to calculate totalCount for this query
  enableTotal: Boolean
  # OpenCRUD fields
  where: StatisticsSelectorInput
  orderBy: StatisticsOrderByInput
  skip: Int
  after: String
  before: String
  first: Int
  last: Int
}

type SingleStatisticsOutput{
  result: Statistics
}

type MultiStatisticsOutput{
  results: [Statistics]
  totalCount: Int
}

type StatisticsOutput{
  data: Statistics
}

input CreateStatisticsInput{
  data: CreateStatisticsDataInput!
}

input CreateStatisticsDataInput {
  episodics: [JSON]
  pilots: [JSON]
  features: [JSON]
  others: [JSON]
}

input UpdateStatisticsInput{
  selector: StatisticsSelectorUniqueInput!
  data: UpdateStatisticsDataInput!
}

input UpsertStatisticsInput{
  selector: StatisticsSelectorUniqueInput!
  data: UpdateStatisticsDataInput!
}

input UpdateStatisticsDataInput {
  episodics: [JSON]
  pilots: [JSON]
  features: [JSON]
  others: [JSON]
}

input StatisticsSelectorInput {
  AND: [StatisticsSelectorInput]
  OR: [StatisticsSelectorInput]

}

input StatisticsSelectorUniqueInput {
  _id: String
  documentId: String # OpenCRUD backwards compatibility
  slug: String

}

enum StatisticsOrderByInput {
  foobar

}




type Query {
  SiteData: Site

  currentUser: User

  user(input: SingleUserInput): SingleUserOutput

  users(input: MultiUserInput): MultiUserOutput

  settings(input: MultiSettingInput): MultiSettingOutput

  callbacks(input: MultiCallbackInput): MultiCallbackOutput

  # A single Project document fetched by ID or slug
  project(input: SingleProjectInput): SingleProjectOutput

  # A list of Project documents matching a set of query terms
  projects(input: MultiProjectInput): MultiProjectOutput

  # A single PastProject document fetched by ID or slug
  pastProject(input: SinglePastProjectInput): SinglePastProjectOutput

  # A list of PastProject documents matching a set of query terms
  pastProjects(input: MultiPastProjectInput): MultiPastProjectOutput

  # A single Office document fetched by ID or slug
  office(input: SingleOfficeInput): SingleOfficeOutput

  # A list of Office documents matching a set of query terms
  offices(input: MultiOfficeInput): MultiOfficeOutput

  # A single Contact document fetched by ID or slug
  contact(input: SingleContactInput): SingleContactOutput

  # A list of Contact documents matching a set of query terms
  contacts(input: MultiContactInput): MultiContactOutput

  # A single Comment document fetched by ID or slug
  comment(input: SingleCommentInput): SingleCommentOutput

  # A list of Comment documents matching a set of query terms
  comments(input: MultiCommentInput): MultiCommentOutput

  # A single Statistic document fetched by ID or slug
  statistics(input: SingleStatisticsInput): SingleStatisticsOutput

  # A list of Statistic documents matching a set of query terms
  statisticses(input: MultiStatisticsInput): MultiStatisticsOutput

}


type Mutation {
  createUser(data: CreateUserDataInput!) : UserOutput

  updateUser(selector: UserSelectorUniqueInput!, data: UpdateUserDataInput! ) : UserOutput

  deleteUser(selector: UserSelectorUniqueInput!) : UserOutput

  # Mutation for creating new Project documents
  createProject(data: CreateProjectDataInput!) : ProjectOutput

  # Mutation for updating a Project document
  updateProject(selector: ProjectSelectorUniqueInput!, data: UpdateProjectDataInput! ) : ProjectOutput

  # Mutation for upserting a Project document
  upsertProject(selector: ProjectSelectorUniqueInput!, data: UpdateProjectDataInput! ) : ProjectOutput

  # Mutation for deleting a Project document
  deleteProject(selector: ProjectSelectorUniqueInput!) : ProjectOutput

  # Mutation for creating new PastProject documents
  createPastProject(data: CreatePastProjectDataInput!) : PastProjectOutput

  # Mutation for updating a PastProject document
  updatePastProject(selector: PastProjectSelectorUniqueInput!, data: UpdatePastProjectDataInput! ) : PastProjectOutput

  # Mutation for upserting a PastProject document
  upsertPastProject(selector: PastProjectSelectorUniqueInput!, data: UpdatePastProjectDataInput! ) : PastProjectOutput

  # Mutation for deleting a PastProject document
  deletePastProject(selector: PastProjectSelectorUniqueInput!) : PastProjectOutput

  # Mutation for creating new Office documents
  createOffice(data: CreateOfficeDataInput!) : OfficeOutput

  # Mutation for updating a Office document
  updateOffice(selector: OfficeSelectorUniqueInput!, data: UpdateOfficeDataInput! ) : OfficeOutput

  # Mutation for upserting a Office document
  upsertOffice(selector: OfficeSelectorUniqueInput!, data: UpdateOfficeDataInput! ) : OfficeOutput

  # Mutation for deleting a Office document
  deleteOffice(selector: OfficeSelectorUniqueInput!) : OfficeOutput

  # Mutation for creating new Contact documents
  createContact(data: CreateContactDataInput!) : ContactOutput

  # Mutation for updating a Contact document
  updateContact(selector: ContactSelectorUniqueInput!, data: UpdateContactDataInput! ) : ContactOutput

  # Mutation for upserting a Contact document
  upsertContact(selector: ContactSelectorUniqueInput!, data: UpdateContactDataInput! ) : ContactOutput

  # Mutation for deleting a Contact document
  deleteContact(selector: ContactSelectorUniqueInput!) : ContactOutput

  # Mutation for creating new Comment documents
  createComment(data: CreateCommentDataInput!) : CommentOutput

  # Mutation for updating a Comment document
  updateComment(selector: CommentSelectorUniqueInput!, data: UpdateCommentDataInput! ) : CommentOutput

  # Mutation for upserting a Comment document
  upsertComment(selector: CommentSelectorUniqueInput!, data: UpdateCommentDataInput! ) : CommentOutput

  # Mutation for deleting a Comment document
  deleteComment(selector: CommentSelectorUniqueInput!) : CommentOutput

  # Mutation for creating new Statistic documents
  createStatistics(data: CreateStatisticsDataInput!) : StatisticsOutput

  # Mutation for updating a Statistic document
  updateStatistics(selector: StatisticsSelectorUniqueInput!, data: UpdateStatisticsDataInput! ) : StatisticsOutput

  # Mutation for upserting a Statistic document
  upsertStatistics(selector: StatisticsSelectorUniqueInput!, data: UpdateStatisticsDataInput! ) : StatisticsOutput

  # Mutation for deleting a Statistic document
  deleteStatistics(selector: StatisticsSelectorUniqueInput!) : StatisticsOutput

}
